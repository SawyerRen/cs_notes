# 第三章：存储与检索

## 数据库的数据结构

* 许多数据库在内部使用了 **日志（log）**，也就是一个 **仅追加（append-only）** 的数据文件。
* 为了高效查找数据库中特定键的值，我们需要一个数据结构：**索引（index）**。

### 散列索引

既然我们已经可以用散列映射来表示 **内存中** 的数据结构，为什么不使用它来索引 **硬盘上** 的数据呢？

保留一个内存中的散列映射，其中每个键都映射到数据文件中的一个字节偏移量，指明了可以找到对应值的位置。当你将新的键值对追加写入文件中时，还要更新散列映射，以反映刚刚写入的数据的偏移量（这同时适用于插入新键与更新现有键）。当你想查找一个值时，使用散列映射来查找数据文件中的偏移量，**寻找（seek）** 该位置并读取该值即可。这种存储引擎适合每个键的值经常更新的情况。

现在我们一直在追加写入日志文件，如何避免这个日志文件过大呢？我们可以在日志增长到特定大小后关闭当前文件，并开始写入一个新的文件，再对之前的文件进行压缩，只保留每个键的最新值。之后我们还可以把多个段压缩到一起，写入一个新的文件，旧的文件就可以删除掉了。

需要考虑的点：

* 文件格式用二进制更快，直接用字符串的字节长度编码
* 删除的时候，需要添加一个删除记录，再压缩合并的时候把历史值都删掉
* 数据库重新启动时需要读取整个日志文件，如果日志文件很大，恢复会很慢，可以把日志快照写入硬盘
* 写线程一般只有一个，但是可以有多个读线程

为什么不直接用新值覆盖旧值呢？**追加写入时有好处的：**

* 顺序写入的操作相较于随机写入快很多
* 并发和崩溃恢复会比较简单
* 合并操作也会比较简单

**散列索引的坏处：**

* 散列表必须放入内存
* 范围查询效率低
